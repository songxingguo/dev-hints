<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  


  
  <title>微信小程序文档 | 开发宝典</title>
  
    <link rel="icon" href="/img/light.png">
  
  <link rel="stylesheet" href="../css/style.css">
  <link rel="stylesheet" href="../css/flex.css">

</head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <section id="main"><article id="post-wziw8o" class="article article-type-post" itemscope itemprop="blogPost">
  <nav class='top-nav' data-js-no-preview role='navigation'>
  <div class='container'>
      <div class='left'>
        <a class='home back-button' href='/'></a>
      </div>

      <div class='actions'>
          <ul class='page-actions flex-row'>
              
                  <li class='link yuque -button hint--bottom' data-hint='Edit'>
                      <a href='https://www.yuque.com/songxingguo/devhints/wziw8o/edit' target="_blank" rel="noopener">
                          <span class='text -visible'>Edit</span>
                      </a>
                  </li>
              
             
          </ul>
      </div>
  </div>
</nav>


  <div class='body-area'>
    <header class='main-heading -center' role='banner'>
      <h1 class='h1'> 微信小程序文档 <em></em></h1>
    </header>


    <main class='post-content MarkdownBody' data-js-main-body data-js-anchors role='main'>
      <h3 id="小程序的运行环境"><a href="#小程序的运行环境" class="headerlink" title="小程序的运行环境"></a>小程序的运行环境</h3><p>网页开发者需要面对的环境是各式各样的浏览器，PC 端需要面对 IE、Chrome、QQ浏览器等，在移动端需要面对Safari、Chrome以及 iOS、Android 系统中的各式 WebView 。而小程序开发过程中需要面对的是两大操作系统 iOS 和 Android 的微信客户端，以及用于辅助开发的小程序开发者工具，小程序中三大运行环境也是有所区别的，如表1-1所示。</p>
<table>
<thead>
<tr>
<th align="left"><strong>运行环境</strong></th>
<th align="left"><strong>逻辑层</strong></th>
<th align="left"><strong>渲染层</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">iOS</td>
<td align="left">JavaScriptCore</td>
<td align="left">WKWebView</td>
</tr>
<tr>
<td align="left">安卓</td>
<td align="left">V8</td>
<td align="left">chromium定制内核</td>
</tr>
<tr>
<td align="left">小程序开发者工具</td>
<td align="left">NWJS</td>
<td align="left">Chrome WebView</td>
</tr>
</tbody></table>
<p><br />MVVM 的开发模式（例如 React, Vue），提倡把渲染和逻辑分离。简单来说就是不要再让 <code>JS</code> 直接操控 <code>DOM</code>，<code>JS</code> 只需要管理状态即可，然后再通过一种模板语法来描述状态和界面结构的关系即可。</p>
<h3 id="渲染层和逻辑层"><a href="#渲染层和逻辑层" class="headerlink" title="渲染层和逻辑层"></a>渲染层和逻辑层</h3><p>首先，我们来简单了解下小程序的运行环境。小程序的运行环境分成渲染层和逻辑层，其中 WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。<br />小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了WebView 进行渲染；逻辑层采用JsCore线程运行JS脚本。一个小程序存在多个界面，所以渲染层存在多个WebView线程，这两个线程的通信会经由微信客户端（下文中也会采用Native来代指微信客户端）做中转，逻辑层发送网络请求也经由Native转发，小程序的通信模型下图所示。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/394169/1608369101869-23c83af8-04aa-4551-969c-b2b855e0e4aa.png#align=left&display=inline&height=873&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1746&originWidth=2356&size=245216&status=done&style=none&width=1178" alt="image.png"></p>
<h3 id="协作开发"><a href="#协作开发" class="headerlink" title="协作开发"></a>协作开发</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/394169/1608369392243-4a71107c-256b-4ace-a209-854c5f402fe3.png#align=left&display=inline&height=295&margin=%5Bobject%20Object%5D&name=image.png&originHeight=590&originWidth=1178&size=26014&status=done&style=none&width=589" alt="image.png"><br />项目管理成员负责统筹整个项目的进展和风险、把控小程序对外发布的节奏，产品组提出需求，设计组与产品讨论并对需求进行抽象，设计出可视化流程与图形，输出设计方案。开发组依据设计方案，进行程序代码的编写，代码编写完成后，产品组与设计组体验小程序的整体流程，测试组编写测试用例并对小程序进行各种边界测试。项目一般的成员构成与工作流程如图5-2所示。<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/394169/1608369401897-f4a34f59-7319-4485-968c-1c2690d5f93a.png#align=left&display=inline&height=216&margin=%5Bobject%20Object%5D&name=image.png&originHeight=432&originWidth=1458&size=34148&status=done&style=none&width=729" alt="image.png"><br />一般的软件开发流程，开发者编写代码自测开发版程序，直到程序达到一个稳定可体验的状态时，开发者会把这个体验版本给到产品经理和测试人员进行体验测试，最后修复完程序的Bug后发布供外部用户正式使用。小程序的版本根据这个流程设计了小程序版本的概念，如表5-3所示。</p>
<p>因为处于开发中的版本是不稳定的，开发者随时会修改代码覆盖开发版，为了让测试和产品经理有一个完整稳定的版本可以体验测试，小程序平台允许把其中一个开发版本设置成体验版，因此建议在项目开发阶段特殊分配一个开发角色，用于上传稳定可供体验测试的代码，并把他上传的开发版本设置成体验版。<br /></p>
<h3 id="小程序框架"><a href="#小程序框架" class="headerlink" title="小程序框架"></a>小程序框架</h3><pre><code class="javascript">// xxx.js
const appInstance = getApp()
console.log(appInstance.globalData) // I am global data</code></pre>
<h4 id="页面生命周期"><a href="#页面生命周期" class="headerlink" title="页面生命周期"></a>页面生命周期</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/394169/1608370623598-88f0e485-047c-4b7b-9a83-05a7a158e19d.png#align=left&display=inline&height=1014&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1014&originWidth=662&size=59224&status=done&style=none&width=662" alt="image.png"><br /></p>
<h4 id="异步-API-返回-Promise"><a href="#异步-API-返回-Promise" class="headerlink" title="异步 API 返回 Promise"></a>异步 API 返回 Promise</h4><ol>
<li>当没有回调参数时，异步接口返回 promise。此时若函数调用失败进入 fail 逻辑， 会报错提示 <code>Uncaught (in promise)</code>，开发者可通过 catch 来进行捕获。</li>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onUnhandledRejection.html" target="_blank" rel="noopener">wx.onUnhandledRejection</a> 可以监听未处理的 Promise 拒绝事件。</li>
</ol>
<h4 id="尺寸单位"><a href="#尺寸单位" class="headerlink" title="尺寸单位"></a>尺寸单位</h4><ul>
<li>rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。<table>
<thead>
<tr>
<th align="left">设备</th>
<th align="left">rpx换算px (屏幕宽度/750)</th>
<th align="left">px换算rpx (750/屏幕宽度)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">iPhone5</td>
<td align="left">1rpx = 0.42px</td>
<td align="left">1px = 2.34rpx</td>
</tr>
<tr>
<td align="left">iPhone6</td>
<td align="left">1rpx = 0.5px</td>
<td align="left">1px = 2rpx</td>
</tr>
<tr>
<td align="left">iPhone6 Plus</td>
<td align="left">1rpx = 0.552px</td>
<td align="left">1px = 1.81rpx</td>
</tr>
</tbody></table>
</li>
</ul>
<p><strong>建议：</strong> 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。<br /><strong>注意：</strong> 在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况。</p>
<h4 id="事件分类"><a href="#事件分类" class="headerlink" title="事件分类"></a>事件分类</h4><p>事件分为冒泡事件和非冒泡事件：</p>
<ol>
<li>冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。</li>
<li>非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。</li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>WXML的冒泡事件列表：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">触发条件</th>
<th align="left">最低版本</th>
</tr>
</thead>
<tbody><tr>
<td align="left">touchstart</td>
<td align="left">手指触摸动作开始</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">touchmove</td>
<td align="left">手指触摸后移动</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">touchcancel</td>
<td align="left">手指触摸动作被打断，如来电提醒，弹窗</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">touchend</td>
<td align="left">手指触摸动作结束</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">tap</td>
<td align="left">手指触摸后马上离开</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">longpress</td>
<td align="left">手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发</td>
<td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener">1.5.0</a></td>
</tr>
<tr>
<td align="left">longtap</td>
<td align="left">手指触摸后，超过350ms再离开（推荐使用longpress事件代替）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">transitionend</td>
<td align="left">会在 WXSS transition 或 wx.createAnimation 动画结束后触发</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">animationstart</td>
<td align="left">会在一个 WXSS animation 动画开始时触发</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">animationiteration</td>
<td align="left">会在一个 WXSS animation 一次迭代结束时触发</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">animationend</td>
<td align="left">会在一个 WXSS animation 动画完成时触发</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">touchforcechange</td>
<td align="left">在支持 3D Touch 的 iPhone 设备，重按时会触发</td>
<td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener">1.9.90</a></td>
</tr>
</tbody></table>
<h4 id="事件的捕获阶段"><a href="#事件的捕获阶段" class="headerlink" title="事件的捕获阶段"></a>事件的捕获阶段</h4><p>自基础库版本 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html" target="_blank" rel="noopener">1.5.0</a> 起，触摸类事件支持捕获阶段。捕获阶段位于冒泡阶段之前，且在捕获阶段中，事件到达节点的顺序与冒泡阶段恰好相反。需要在捕获阶段监听事件时，可以采用<code>capture-bind</code>、<code>capture-catch</code>关键字，后者将中断捕获阶段和取消冒泡阶段。<br /><br><br /><br><br /></p>

    </main>
  </div>

  <div class='pre-footer' data-js-no-preview><i class='icon'></i></div>

</article>



<script src="https://cdn.jsdelivr.net/npm/prismjs@1.17.1/prism.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.17.1/plugins/autoloader/prism-autoloader.min.js"></script>
<script src="../js/article.js"></script>


</section>
      </div>
    </div>
    <!-- <nav id="mobile-nav">
  
</nav> -->
    <!-- 

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>





 -->
  </div>

</body>
</html>
